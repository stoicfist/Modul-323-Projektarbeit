\documentclass[a4paper,11pt]{article}

% --------------------
% Pakete
% --------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=blue,     % interne Links (Inhaltsverzeichnis etc.)
  urlcolor=blue,      % URLs
  citecolor=blue      % Literaturzitate (falls du später welche hast)
}

\geometry{margin=2.5cm}
\onehalfspacing

% --- Darkmode Farben für Code ---
\definecolor{codebg}{HTML}{0B0F14}      % sehr dunkles Blau-Schwarz
\definecolor{codefg}{HTML}{E6D5B8}      % beige
\definecolor{codekw}{HTML}{7AA2F7}      % blau (Keywords)
\definecolor{codestr}{HTML}{E0AF68}     % orange/beige (Strings)
\definecolor{codecom}{HTML}{7F8C8D}     % grau (Kommentare)
\definecolor{codenum}{HTML}{56687A}     % grau-blau (Zeilennummern)
\definecolor{codeframe}{HTML}{1F2A37}   % Rahmen

% --------------------
% Code-Style
% --------------------
\lstset{
  language=Python,
  basicstyle=\ttfamily\small\color{codefg},
  backgroundcolor=\color{codebg},
  keywordstyle=\bfseries\color{codekw},
  stringstyle=\color{codestr},
  commentstyle=\itshape\color{codecom},
  numbers=left,
  numberstyle=\tiny\color{codenum},
  stepnumber=1,
  numbersep=8pt,
  frame=single,
  rulecolor=\color{codeframe},
  breaklines=true,
  breakatwhitespace=true,
  showstringspaces=false,
  tabsize=4,
  keepspaces=true
}

% --------------------
% Dokument
% --------------------
\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2cm}

    {\Large Modul M323 – Funktionales Programmieren\par}
    \vspace{1cm}
    {\Huge\bfseries Bank Marketing Data – Kundenanalyse \& Abschlussprognose\par}
    \vspace{1.5cm}

    {\large Projekt-Dokumentation\par}
    \vspace{2cm}

    \begin{tabular}{ll}
        Autoren: & Peter Ngo, Alex Uscata \\
        Klasse : & INA 23A \\
        Dozent: & Dieter Kopp \\
        Datum: & \today
    \end{tabular}

    \vfill
\end{titlepage}

\tableofcontents
\newpage

% ======================================================
\section{Einleitung}

Im Rahmen des Moduls M323 – Funktionales Programmieren wird in diesem Projekt
eine Datenanalyse einer Bank-Marketingkampagne umgesetzt.
Ziel ist es, eine imperativ geschriebene Lösung mit einer funktional
refaktorierten Version zu vergleichen und die Vor- sowie Nachteile
funktionaler Sprachelemente praxisnah zu evaluieren.

Als Datengrundlage dient ein realitätsnaher Datensatz einer portugiesischen
Bank, welcher Kundendaten sowie den Erfolg einer Marketingkampagne enthält.
Beide Programmversionen erzeugen denselben Output, unterscheiden sich jedoch
grundlegend in der Programmierweise.

% ======================================================
\section{Wahl der imperativen Programmiersprache}

\subsection{Begründung der Sprachwahl}

Für dieses Projekt wurde die Programmiersprache \textbf{Python} gewählt.
Python eignet sich besonders gut für Datenanalysen, da die Sprache:

\begin{itemize}
    \item leicht lesbar und verständlich ist
    \item imperative Programmierung vollständig unterstützt
    \item funktionale Sprachelemente integriert anbietet
    \item häufig im beruflichen Umfeld eingesetzt wird
\end{itemize}

Da Python sowohl imperative als auch funktionale Konzepte vereint, ist die
Sprache ideal geeignet, um beide Programmierparadigmen direkt miteinander
zu vergleichen.

\subsection{Unterstützte funktionale Elemente in Python}

Python ist keine rein funktionale Sprache, bietet jedoch zahlreiche
funktionale Sprachelemente aus der Standardbibliothek:

\begin{itemize}
    \item \texttt{map()} – Transformation von Daten
    \item \texttt{filter()} – Selektion von Elementen
    \item \texttt{reduce()} (aus \texttt{functools}) – Aggregation
    \item Lambda-Funktionen
    \item List Comprehensions
    \item Unveränderliche Datentypen (z.\,B. Tupel)
\end{itemize}

Diese Elemente ermöglichen eine deklarative und kompakte Beschreibung
von Datenverarbeitungslogik.

\subsubsection{Kurzbeispiele der funktionalen Elemente}

\begin{lstlisting}[language=Python]
# map: Transformation
list(map(lambda x: x*x, [1,2,3]))      # -> [1,4,9]

# filter: Selektion
list(filter(lambda x: x > 2, [1,2,3])) # -> [3]

# reduce: Aggregation
from functools import reduce
reduce(lambda acc, x: acc + x, [1,2,3], 0)  # -> 6
\end{lstlisting}


% ======================================================
\section{Projektantrag}

\subsection{Ausgangslage}

Während einer Marketingkampagne hat eine Bank verschiedene Kundendaten
erfasst. Der Datensatz liegt in Form einer CSV-Datei vor und ist nicht
direkt für Analysen aufbereitet.

Ziel ist es, relevante Kennzahlen zu berechnen, Kundengruppen zu vergleichen
und statistische Zusammenhänge zu untersuchen.

\subsection{Zielsetzung}

Das Projekt verfolgt folgende Ziele:

\begin{itemize}
    \item Analyse der Erfolgsquote der Marketingkampagne
    \item Vergleich verschiedener Kundengruppen
    \item Umsetzung einer imperativen Version (V1.0)
    \item Refactoring in eine funktionale Version (V2.0)
    \item Vergleich beider Ansätze hinsichtlich Lesbarkeit und Wartbarkeit
\end{itemize}

\subsection{Projektumfang}

Das Projekt umfasst:

\begin{itemize}
    \item Einlesen und Verarbeiten eines CSV-Datensatzes
    \item Textbasierte Konsolenausgabe
    \item Keine externen Bibliotheken
    \item Umsetzung in Python; Ausführung und Dokumentation der Experimente in einem Jupyter Notebook (Tooling).
\end{itemize}

% ======================================================
\section{Programmausgabe}

Beide Versionen des Programms erzeugen denselben Output.
Die Ausgabe erfolgt textbasiert in der Konsole.

\subsection{Beispielhafter Output}

\begin{lstlisting}
===========================
Bankkampagne – Erfolgsquote

Anzahl Kunden: 4521
Abschlüsse (yes): 512
Erfolgsquote: 11.3 %

===========================
Vergleich nach Education

primary   | Ø Balance: 850  | Erfolgsquote: 8.5 %
secondary | Ø Balance: 1200 | Erfolgsquote: 10.1 %
tertiary  | Ø Balance: 1800 | Erfolgsquote: 14.3 %

ANOVA F-Wert: 5.21
\end{lstlisting}

\textit{Hinweis:} Version 1.0 (imperativ) und Version 2.0 (funktional)
liefern identische Resultate.

% ======================================================
\section{Refactoring: Vergleich Version 1.0 vs. Version 2.0}

Beide Programmversionen implementieren dieselben Produktfunktionen und erzeugen identische Resultate, unterscheiden sich jedoch in der Umsetzung:
Version 1.0 verwendet primär imperative Sprachmittel (Schleifen, Hilfsvariablen, schrittweiser Aufbau von Resultaten),
während Version 2.0 die gleiche Logik mit funktionalen Sprachmitteln (z.\,B. \texttt{map}, \texttt{filter}, \texttt{reduce}, Lambdas) ausdrückt.

\subsection{Konkrete Beispiele aus dem Projekt}

\paragraph{Beispiel A: Filtern von Datensätzen}
In Version 1.0 wird die Filterlogik mit einer Schleife und \texttt{continue} umgesetzt.
In Version 2.0 wird dieselbe Logik deklarativ als Prädikatfunktion formuliert und per \texttt{filter} angewendet.

\begin{lstlisting}[language=Python]
# V1.0 (imperativ) - skizziert
out = []
for row in data:
    if housing is not None and row["housing"] is not housing:
        continue
    if loan is not None and row["loan"] is not loan:
        continue
    out.append(row)

# V2.0 (funktional) - skizziert
def pred(row):
    ...
    return True/False

out = list(filter(pred, data))
\end{lstlisting}

\paragraph{Beispiel B: Aggregation (Tabellenbreiten via reduce)}
Für die tabellarische Ausgabe werden in Version 2.0 Spaltenbreiten über ein \texttt{reduce}-Faltungsmuster berechnet,
während Version 1.0 die Breiten schrittweise in Schleifen aktualisiert.

\begin{lstlisting}[language=Python]
# V2.0 (funktional) - skizziert
widths = reduce(update_widths, rows, widths_init)
\end{lstlisting}

\paragraph{Beispiel C: Transformation numerischer Werte (map)}
Transformationen wie \texttt{balance\^{}2 + 1} werden in Version 2.0 direkt als Abbildung über die Liste beschrieben
(\texttt{map} + Lambda), während Version 1.0 die Werte typischerweise in einer Schleife sammelt.

\begin{lstlisting}[language=Python]
# V2.0 (funktional) - skizziert
sq1 = list(map(lambda b: b*b + 1.0, balances))
\end{lstlisting}

\subsection{Zusammenfassung der Unterschiede}

\begin{itemize}
  \item \textbf{Lesbarkeit:} Version 2.0 ist kompakter und beschreibt häufig \emph{was} berechnet wird, statt \emph{wie}.
  \item \textbf{Wartbarkeit:} Wiederverwendbare Hilfsfunktionen (Prädikate, Mapping-Funktionen) reduzieren Duplikation.
  \item \textbf{Fehleranfälligkeit:} Weniger mutable Zwischenzustände und weniger Hilfsvariablen verringern typische Fehlerquellen.
\end{itemize}


% ======================================================
\section{Fazit}

\subsection{Nutzen funktionaler Elemente}

Der Einsatz funktionaler Sprachelemente hat in diesem Projekt mehrere
Vorteile gebracht. Insbesondere Filter- und Transformationsoperationen
konnten kompakter und klarer formuliert werden.

\subsection{Vereinfachung durch Refactoring}

Im Vergleich zur imperativen Version reduzierte sich die Code-Länge
in Version 2.0 deutlich. Verschachtelte Schleifen und Hilfsvariablen
konnten durch deklarative Ausdrücke ersetzt werden.
Dies führte zu besserer Lesbarkeit und weniger Fehleranfälligkeit.

\subsection{Wiederverwendung funktionaler Konzepte}

Die funktionalen Konzepte würden in zukünftigen Projekten erneut
eingesetzt werden, insbesondere bei:

\begin{itemize}
    \item Datenfiltern
    \item Aggregationen
    \item Transformationen von Listen und Datensätzen
\end{itemize}

\subsection{Anwendungsfälle im beruflichen Umfeld}

Im betrieblichen Kontext eignen sich funktionale Sprachelemente besonders
für:

\begin{itemize}
    \item Datenanalyse
    \item Reporting
    \item Verarbeitung von Log- oder Kundendaten
    \item Automatisierte Auswertungen
\end{itemize}

\noindent
Zusammenfassend lässt sich sagen, dass funktionale Programmieransätze
eine sinnvolle Ergänzung zur imperativen Programmierung darstellen und
in vielen Anwendungsfällen zu einer klareren und effizienteren Lösung führen. \\

\newline
\noindent\textit{Hinweis:} Der vollständige Quellcode befindet sich im Projekt-Repository:
\href{https://github.com/stoicfist/Modul-323-Projektarbeit}{github.com/stoicfist/Modul-323-Projektarbeit}.
Er wurde in dieser Dokumentation bewusst nicht vollständig abgedruckt, um den Fokus auf Konzept und Vergleich zu legen.

\end{document}
